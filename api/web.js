const { fetchHarga } = require('../src/utils/harga');
const { analyzeStock } = require('../src/utils/analisys');
const { analyzeWithAI } = require('../src/utils/ai');
const {
    fetchHistorical,
    analyzeProxyBrokerActivity,
    formatProxyBrokerActivity,
    fetchFundamentals,
    formatFundamentals,
    fetchProfile,
    formatProfile,
    fetchSectors
} = require('../src/utils/yahoofinance');
const { getPersistentCandles } = require('../src/utils/persistence');
const { computeIndicators, formatIndicatorsForPrompt } = require('../src/utils/indicators');
const { calculateAvg, formatAvgReport } = require('../src/utils/avg');
const { markdownToTelegramHTML } = require('../src/utils/telegram');
const jwt = require('jsonwebtoken');
const { supabase } = require('../src/utils/supabase');
const axios = require('axios');

// Cache for live quotes to prevent hitting Yahoo Finance too often
const quoteCache = new Map();
const CACHE_TTL = 30000; // 30 seconds (increased from 8s)

// Cache for Sector Heatmap
let sectorsCache = null;
let sectorsCacheTime = 0;
const SECTOR_CACHE_TTL = 15 * 60 * 1000; // 15 minutes

// Cache for Sector Emitents (per sector)
const sectorEmitentsCache = new Map();
const SECTOR_EMITENTS_CACHE_TTL = 30 * 60 * 1000; // 30 minutes
// Remove static require
// const { marked } = require('marked');

// Dynamic import helper
let marked;
async function loadMarked() {
    if (!marked) marked = (await import("marked")).marked;
    return marked;
}

// Helper to remove HTML tags or markdown if needed for simple display, 
// but we might want to keep some specific formatting for the web.
// For now, we'll return raw text or HTML as generated by the utils.

async function checkTelegramMembership(userId, groupId, token, retries = 3) {
    const url = `https://api.telegram.org/bot${token}/getChatMember`;
    for (let i = 0; i < retries; i++) {
        try {
            console.log(`[TELEGRAM] Membership check attempt ${i + 1} for ${userId} in ${groupId}`);
            const response = await axios.get(url, {
                params: { chat_id: groupId, user_id: userId },
                timeout: 8000 // 8 second timeout
            });
            return response.data.result.status;
        } catch (error) {
            const isTimeout = error.code === 'ETIMEDOUT' || error.message.includes('timeout');
            if (i === retries - 1 || !isTimeout) {
                console.error(`[TELEGRAM] Final attempt failed for ${userId}:`, error.message);
                throw error;
            }
            console.warn(`[TELEGRAM] Attempt ${i + 1} timed out, retrying in 2s...`);
            await new Promise(r => setTimeout(r, 2000));
        }
    }
}

module.exports = async (req, res) => {
    // Enable CORS
    res.setHeader('Access-Control-Allow-Credentials', true);
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader(
        'Access-Control-Allow-Headers',
        'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version, Authorization'
    );

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method Not Allowed' });
    }

    try {
        const { action, symbol } = req.body;
        console.log(`[WEB API] Action: ${action}, Symbol: ${symbol}`);

        let activeTheme = 'default';

        // --- Authentication Middleware ---
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            console.warn('[WEB API] Unauthorized: Missing token');
            return res.status(401).json({ error: 'Unauthorized: Missing token' });
        }

        const token = authHeader.split(' ')[1];

        let decoded;
        try {
            decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret-aston');
        } catch (jwtErr) {
            console.warn(`[WEB API] JWT Error: ${jwtErr.message}`);
            return res.status(401).json({ error: 'Unauthorized: Invalid token' });
        }

        console.log(`[WEB API] Token verified for: ${decoded.userId || 'unknown'}`);

        // Check session in DB

        // Check session in DB
        const { data: session, error: sessionError } = await supabase
            .from('sessions')
            .select('user_id, users(*)')
            .eq('token', token)
            .single();

        if (sessionError || !session || !session.users.is_active) {
            return res.status(401).json({ error: 'Unauthorized: Invalid or inactive session' });
        }

        const user = session.users;
        const isAdmin = user.telegram_user_id.toString() === (process.env.ADMIN_ID || '');

        // Update Last Seen [NEW]
        // We do this asynchronously to not block the main request
        supabase.from('users').update({ last_seen_at: new Date().toISOString() }).eq('id', user.id).then(({ error }) => {
            if (error) console.error('[WEB API] Failed to update last_seen_at:', error.message);
        });

        // --- Maintenance & Theme Logic ---
        const { data: appData } = await supabase
            .from('app_settings')
            .select('key, value')
            .in('key', ['maintenance_mode', 'maintenance_end_time', 'active_theme', 'paywall_mode', 'feature_permissions', 'maintenance_whitelist', 'live_mode_whitelist', 'cooldown_mode']);

        const settingsMap = {};
        if (appData) {
            appData.forEach(item => settingsMap[item.key] = item.value);
        }

        let isMaintenance = settingsMap['maintenance_mode'] || false;
        let maintenanceEndTime = settingsMap['maintenance_end_time'];
        activeTheme = settingsMap['active_theme'] || 'default';
        const paywallMode = settingsMap['paywall_mode'] || false;
        const featurePermissions = settingsMap['feature_permissions'] || {};
        const maintenanceWhitelist = settingsMap['maintenance_whitelist'] || [];
        const liveModeWhitelist = settingsMap['live_mode_whitelist'] || [];
        const cooldownMode = settingsMap['cooldown_mode'] === true || settingsMap['cooldown_mode'] === 'true';
        const isWhitelisted = maintenanceWhitelist.includes(user.telegram_user_id.toString());

        // Auto-Disable Logic
        if (isMaintenance && maintenanceEndTime) {
            const now = new Date();
            const end = new Date(maintenanceEndTime);
            if (now >= end) {
                // Auto Turn Off
                await supabase.from('app_settings').upsert([
                    { key: 'maintenance_mode', value: false },
                    { key: 'maintenance_end_time', value: null }
                ]);
                isMaintenance = false;
                maintenanceEndTime = null;
                console.log('Maintenance Mode Auto-Disabled (Time Reached)');
            }
        }

        // If maintenance is ON and user is NOT admin and NOT whitelisted, block all
        if (isMaintenance && !isAdmin && !isWhitelisted) {
            return res.status(503).json({
                error: 'Mohon maaf APP masih Maintenance',
                code: 'MAINTENANCE_MODE',
                end_time: maintenanceEndTime // Return time for countdown
            });
        }

        // --- Auto-Downgrade & Expiry Check ---
        const now = new Date();
        const expiry = new Date(user.expires_at);

        if (expiry < now) {
            // If they were PRO, they "expire" back to Standard
            if (user.membership_status === 'pro') {
                console.log(`[WEB API] User ${user.telegram_user_id} PRO expired. Downgrading to standard.`);

                // Set new expiry for standard access (3 days from now)
                const newStandardExpiry = new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000);

                const { data: downgradedUser, error: downgradeError } = await supabase
                    .from('users')
                    .update({
                        membership_status: 'standard',
                        expires_at: newStandardExpiry.toISOString()
                    })
                    .eq('id', user.id)
                    .select()
                    .single();

                if (downgradeError) {
                    console.error('[WEB API] Downgrade Error:', downgradeError);
                } else {
                    // Update the local 'user' object so the rest of the request sees them as standard
                    user.membership_status = 'standard';
                    user.expires_at = newStandardExpiry.toISOString();
                }
            } else {
                // If they were already Standard (or anything else), they are truly expired
                return res.status(403).json({ error: 'Access expired. Please re-register.' });
            }
        }

        // --- COOLDOWN MODE CHECK (EARLY) ---
        const yfActions = ['price', 'profile', 'fundamental', 'indicators', 'analysis', 'proxy', 'chart', 'live-quote', 'signal', 'review', 'avg', 'sectors', 'sector-emitents'];
        if (cooldownMode && yfActions.includes(action)) {
            return res.status(200).json({ success: false, error: 'COOLDOWN' });
        }

        // --- Membership Check (CRITICAL) ---
        if (!isAdmin) {
            const CACHE_DURATION = 30 * 60 * 1000; // 30 minutes
            const lastCheck = user.last_membership_check ? new Date(user.last_membership_check).getTime() : 0;
            const isExpired = (Date.now() - lastCheck) > CACHE_DURATION;

            let currentStatus = user.membership_status;
            const groupIds = process.env.ALLOWED_GROUP_IDS ? process.env.ALLOWED_GROUP_IDS.split(',') : [];
            const primaryGroupId = groupIds[0];

            if (currentStatus !== 'member' || isExpired) {
                try {
                    currentStatus = await checkTelegramMembership(user.telegram_user_id, primaryGroupId, process.env.TELEGRAM_TOKEN);

                    // Update Cache in DB
                    await supabase.from('users').update({
                        membership_status: currentStatus,
                        last_membership_check: new Date().toISOString()
                    }).eq('id', user.id);

                } catch (e) {
                    const isTimeout = e.code === 'ETIMEDOUT' || e.message.includes('timeout');
                    console.error('Group check failed in middleware:', e.message);
                    return res.status(500).json({
                        error: isTimeout ? 'Telegram API Timeout. Silakan coba lagi nanti.' : 'Security check failed',
                        details: e.message
                    });
                }
            }

            if (!['creator', 'administrator', 'member'].includes(currentStatus)) {
                return res.status(403).json({ error: 'Jika sudah join silahkan buka ulang App' });
            }
        }

        // --- Paywall Gating Enforcer ---
        // If Paywall Mode is ON, check if user is PRO for specific actions
        if (!isAdmin && paywallMode) {
            // Map actions to permission keys
            const actionToKey = {
                'analysis': 'analysis',
                'signal': 'signal',
                'fundamental': 'fundamental',
                'proxy': 'proxy',
                'profile': 'profile',
                'avg': 'avg',
                'review': 'review',
                'chart/live': 'chart-live',
                'chart': 'chart-data',
                'sectors': 'sectors'
            };

            const permissionKey = actionToKey[action];
            if (permissionKey && featurePermissions[permissionKey] === 'pro') {
                if (user.membership_status !== 'pro') {
                    return res.status(403).json({
                        error: 'Exclusive Feature',
                        code: 'PRO_REQUIRED',
                        hint: 'Upgrade ke PRO untuk mengakses fitur ini.'
                    });
                }
            }
        }


        // --- Admin Specific Actions ---
        if (action === 'toggle-maintenance') {
            if (!isAdmin) return res.status(403).json({ error: 'Akses ditolak: Admin only' });

            const { endTime } = req.body; // Expect ISO string or null
            const newState = !isMaintenance;

            // Prepare updates
            const updates = [
                { key: 'maintenance_mode', value: newState }
            ];

            if (newState && endTime) {
                updates.push({ key: 'maintenance_end_time', value: endTime });
            } else if (!newState) {
                // Clear time if turning off
                updates.push({ key: 'maintenance_end_time', value: null });
            }

            await supabase.from('app_settings').upsert(updates);

            // Return the new end_time so frontend can update immediately
            const returnedEndTime = newState ? endTime : null;
            return res.status(200).json({
                success: true,
                is_maintenance: newState,
                maintenance_end_time: returnedEndTime
            });
        }

        if (action === 'watchlist/list') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { data, error } = await supabase.from('monitor_symbols').select('*').order('symbol');
            if (error) return res.status(400).json({ error: error.message });
            return res.status(200).json({ success: true, data });
        }

        if (action === 'watchlist/add') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { symbol: newSym } = req.body;
            if (!newSym) return res.status(400).json({ error: 'Symbol required' });
            const formattedSym = newSym.toUpperCase().endsWith('.JK') ? newSym.toUpperCase() : `${newSym.toUpperCase()}.JK`;
            const { error } = await supabase.from('monitor_symbols').insert([{ symbol: formattedSym, is_active: true }]);
            if (error) return res.status(400).json({ error: error.message });
            return res.status(200).json({ success: true });
        }

        if (action === 'watchlist/delete') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { symbol: targetSym } = req.body;
            await supabase.from('monitor_symbols').delete().eq('symbol', targetSym);
            return res.status(200).json({ success: true });
        }

        if (action === 'watchlist/toggle') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { symbol: targetSym, is_active } = req.body;
            await supabase.from('monitor_symbols').update({ is_active }).eq('symbol', targetSym);
            return res.status(200).json({ success: true });
        }

        if (action === 'watchlist/batch-toggle') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { is_active } = req.body;
            const { error } = await supabase.from('monitor_symbols').update({ is_active }).not('symbol', 'is', null);
            if (error) return res.status(400).json({ error: error.message });
            return res.status(200).json({ success: true });
        }

        if (action === 'admin/force-scan') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            // For architecture simplicity, we'll try to trigger the internal logic
            const scanner = require('./cron/scanner');
            const mockReq = { body: {} };
            const mockRes = {
                status: (code) => ({ json: (data) => { console.log('Mock Scanner Finish:', data); } })
            };
            scanner(mockReq, mockRes);
            return res.status(200).json({ success: true, message: 'Scanner triggered in background' });
        }

        if (action === 'admin/update-theme') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { theme } = req.body;
            await supabase.from('app_settings').upsert({ key: 'active_theme', value: theme });
            return res.status(200).json({ success: true, theme });
        }

        if (action === 'admin/users/list') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });

            console.log('[ADMIN] Fetching users list...');
            const { data, error } = await supabase
                .from('users')
                .select('id, telegram_user_id, telegram_username, is_live_eligible, is_active, membership_status, expires_at, last_seen_at');

            if (error) {
                console.error('[ADMIN] Fetch Users Error:', error);
                return res.status(400).json({ error: error.message, details: error });
            }
            return res.status(200).json({ success: true, data });
        }

        if (action === 'admin/users/toggle-live') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { userId, is_live_eligible } = req.body;
            const { error } = await supabase.from('users').update({ is_live_eligible }).eq('id', userId);
            if (error) return res.status(400).json({ error: error.message });
            return res.status(200).json({ success: true });
        }

        if (action === 'admin/users/add') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { telegram_user_id } = req.body;
            if (!telegram_user_id) return res.status(400).json({ error: 'Telegram User ID is required' });

            console.log(`[ADMIN] Adding user manual: ${telegram_user_id}`);

            // Create initial expires_at (e.g., 3 days from now)
            const expires_at = new Date();
            expires_at.setDate(expires_at.getDate() + 3);

            const crypto = require('crypto');
            const placeholderHash = crypto.randomBytes(16).toString('hex');

            const payload = {
                telegram_user_id: telegram_user_id.toString(),
                is_active: true,
                is_live_eligible: true,
                expires_at: expires_at.toISOString(),
                membership_status: 'member',
                password_hash: placeholderHash,
                last_login: new Date().toISOString()
            };

            console.log(`[ADMIN] Upsert Payload:`, payload);

            const { data: upsertData, error: upsertError } = await supabase.from('users').upsert([payload], { onConflict: 'telegram_user_id' });

            if (upsertError) {
                console.error(`[ADMIN] Upsert Error:`, upsertError);
                return res.status(400).json({ error: upsertError.message, details: upsertError });
            }

            console.log(`[ADMIN] User added successfully:`, telegram_user_id);
            return res.status(200).json({ success: true });
        }

        // --- NEW ADMIN SUBSCRIPTION ACTIONS ---
        if (action === 'admin/users/extend') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { userId, days } = req.body;
            if (!userId || !days) return res.status(400).json({ error: 'UserID and Days required' });

            // Fetch current expiry
            const { data: u } = await supabase.from('users').select('expires_at').eq('id', userId).single();
            if (!u) return res.status(404).json({ error: 'User not found' });

            const current = new Date(u.expires_at || new Date());
            const base = current < new Date() ? new Date() : current;
            const newExpiry = new Date(base.getTime() + days * 24 * 60 * 60 * 1000);

            const { error } = await supabase.from('users').update({ expires_at: newExpiry.toISOString() }).eq('id', userId);
            if (error) return res.status(400).json({ error: error.message });
            return res.status(200).json({ success: true, expires_at: newExpiry.toISOString() });
        }

        if (action === 'admin/users/update-level') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { userId, level } = req.body; // 'standard' or 'pro'
            if (!userId || !level) return res.status(400).json({ error: 'UserID and Level required' });

            const { error } = await supabase.from('users').update({ membership_status: level }).eq('id', userId);
            if (error) return res.status(400).json({ error: error.message });
            return res.status(200).json({ success: true });
        }

        if (action === 'admin/users/set-expiry') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { userId, expiryDate } = req.body; // ISO string
            if (!userId || !expiryDate) return res.status(400).json({ error: 'UserID and ExpiryDate required' });

            const { error } = await supabase.from('users').update({ expires_at: expiryDate }).eq('id', userId);
            if (error) return res.status(400).json({ error: error.message });
            return res.status(200).json({ success: true });
        }

        if (action === 'admin/settings/update-paywall') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { paywall_mode } = req.body;
            await supabase.from('app_settings').upsert({ key: 'paywall_mode', value: paywall_mode });
            return res.status(200).json({ success: true });
        }

        if (action === 'admin/settings/update-permissions') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { permissions } = req.body; // Object mapping feature keys to 'standard'/'pro'
            await supabase.from('app_settings').upsert({ key: 'feature_permissions', value: permissions });
            return res.status(200).json({ success: true });
        }

        if (action === 'admin/settings/get-whitelist') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { data } = await supabase.from('app_settings').select('value').eq('key', 'maintenance_whitelist').single();
            return res.status(200).json({ success: true, whitelist: data ? data.value : [] });
        }

        if (action === 'admin/settings/update-whitelist') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { whitelist } = req.body;
            await supabase.from('app_settings').upsert({ key: 'maintenance_whitelist', value: whitelist });
            return res.status(200).json({ success: true });
        }

        if (action === 'admin/settings/get-live-whitelist') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { data } = await supabase.from('app_settings').select('value').eq('key', 'live_mode_whitelist').single();
            return res.status(200).json({ success: true, whitelist: data ? data.value : [] });
        }

        if (action === 'admin/settings/update-live-whitelist') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { whitelist } = req.body;
            await supabase.from('app_settings').upsert({ key: 'live_mode_whitelist', value: whitelist });
            return res.status(200).json({ success: true });
        }

        if (action === 'admin/settings/get-cooldown') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { data } = await supabase.from('app_settings').select('value').eq('key', 'cooldown_mode').single();
            const { data: timeData } = await supabase.from('app_settings').select('value').eq('key', 'cooldown_end_time').single();
            return res.status(200).json({
                success: true,
                is_cooldown: data ? data.value : false,
                cooldown_end_time: timeData ? timeData.value : null
            });
        }

        if (action === 'admin/settings/toggle-cooldown') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { is_cooldown } = req.body;
            let endTime = null;
            if (is_cooldown) {
                // Set cooldown for 30 minutes
                endTime = new Date(Date.now() + 30 * 60 * 1000).toISOString();
            }
            await supabase.from('app_settings').upsert([
                { key: 'cooldown_mode', value: is_cooldown },
                { key: 'cooldown_end_time', value: endTime }
            ]);
            return res.status(200).json({ success: true, cooldown_end_time: endTime });
        }

        if (action === 'admin/diagnostics/ip-status') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            try {
                const ipRes = await axios.get('https://api.ipify.org?format=json');
                const ip = ipRes.data.ip;
                // Dummy check YF
                const { data } = await supabase.from('app_settings').select('value').eq('key', 'cooldown_mode').single();
                return res.status(200).json({
                    success: true,
                    ip: ip,
                    yf_status: (data && data.value) ? 'COOLING DOWN' : 'OK'
                });
            } catch (e) {
                return res.status(500).json({ success: false, error: e.message });
            }
        }

        if (action === 'admin/diagnostics/check-connection') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            try {
                const { fetchQuote } = require('../src/utils/yahoofinance');
                const quote = await fetchQuote('BBCA.JK');
                const ok = !!quote;
                return res.status(200).json({
                    success: true,
                    yf_status: ok ? 'OK' : 'BLOCKED/ERROR'
                });
            } catch (e) {
                return res.json({ success: true, yf_status: 'ERROR: ' + e.message });
            }
        }

        // Log MiniApp Usage
        const username = user.telegram_username || `ID:${user.telegram_user_id}`;
        if (action) {
            console.log(`${username} menggunakan miniapp ${action}`);
        }

        // --- End Authentication Middleware ---

        const actionsWithoutSymbol = ['sectors', 'sector-emitents'];
        if (!symbol && !actionsWithoutSymbol.includes(action)) {
            return res.status(400).json({ error: 'Symbol is required' });
        }

        let result = '';

        switch (action) {
            case 'price': // Replaced by Profile
            case 'profile':
                const profileData = await fetchProfile(symbol);
                result = formatProfile(profileData);
                break;

            case 'fundamental':
                const fundData = await fetchFundamentals(symbol);
                if (!fundData) {
                    result = "❌ Data fundamental tidak ditemukan.";
                } else {
                    // For the dedicated page, we want the JSON.
                    // For the legacy bot view, we still need the formatted text.
                    return res.status(200).json({
                        success: true,
                        data: fundData, // Sending raw object
                        formatted: formatFundamentals(fundData),
                        active_theme: activeTheme
                    });
                }
                break;

            case 'quote':
                const { fetchQuote } = require('../src/utils/yahoofinance');
                // Symbol can be comma separated "A,B,C"
                let syms = symbol;
                if (typeof symbol === 'string' && symbol.includes(',')) {
                    syms = symbol.split(',').map(s => s.trim());
                }
                const dict = await fetchQuote(syms);
                return res.status(200).json({
                    success: true,
                    data: dict
                });

            case 'indicators':
                const analysis = await analyzeStock(symbol);
                result = analysis.text || analysis.error;
                break;

            case 'analysis':
                // Replicating /analisa logic
                // Safeguard: Ensure IDX symbol has .JK
                let targetAnalysisSym = symbol;
                if (targetAnalysisSym && !targetAnalysisSym.includes('.') && /^[A-Z]{4}$/.test(targetAnalysisSym)) {
                    targetAnalysisSym = `${targetAnalysisSym}.JK`;
                }

                const candles = await getPersistentCandles(targetAnalysisSym, '1d', 50);
                if (!candles || candles.length === 0) {
                    result = `❌ Data ${targetAnalysisSym} tidak tersedia (Candles Null).`;
                } else {
                    const indicators = computeIndicators(candles);
                    const prompt = formatIndicatorsForPrompt(targetAnalysisSym, indicators);
                    result = await analyzeWithAI(prompt);
                }
                break;

            case 'proxy':
                // Replicating /proxy logic
                const candlesProxy = await getPersistentCandles(symbol, '1d', 120);
                const activity = analyzeProxyBrokerActivity(candlesProxy);
                result = formatProxyBrokerActivity(symbol, activity);
                break;

            case 'chart':
                // Dynamic import to keep init fast
                const { getChartData } = require('../src/utils/charting');
                const interval = req.body.interval || '1d';
                const limit = req.body.limit || 300;
                console.log(`[API] Processing chart request for ${symbol} interval ${interval} limit ${limit}`);

                try {
                    const chartData = await getChartData(symbol, interval, limit);
                    console.log(`[API] Returning chart data: ${chartData.candles.length} candles, ${chartData.markers.length} markers`);

                    // Check if user is eligible for live mode (Strictly Whitelist Driven)
                    const isLiveEligible = liveModeWhitelist.includes(user.telegram_user_id.toString());

                    // Directly return JSON, bypass HTML formatting logic
                    return res.status(200).json({
                        success: true,
                        data: chartData,
                        is_live_eligible: isLiveEligible
                    });
                } catch (error) {
                    console.error(`[API] Chart Error:`, error);
                    return res.status(500).json({ success: false, error: error.message });
                }

            case 'live-quote':
                const intervalLive = req.body.interval || '1d';
                const liveCacheKey = `${symbol}_${intervalLive}`;
                const cachedBody = quoteCache.get(liveCacheKey);

                if (cachedBody && (Date.now() - cachedBody.timestamp < CACHE_TTL)) {
                    console.log(`[LIVE API] Cache Hit for ${liveCacheKey}`);
                    return res.status(200).json({ success: true, data: cachedBody.data });
                }

                try {
                    const { fetchHistorical } = require('../src/utils/yahoofinance');
                    // Fetch last 2 candles to ensure we have the most recent one (some intervals might be laggy)
                    // We use forceRefresh: true here to ensure we get live data
                    const liveCandles = await fetchHistorical(symbol, { interval: intervalLive, limit: 2, forceRefresh: true });

                    if (liveCandles && liveCandles.length > 0) {
                        const lastCandle = liveCandles[liveCandles.length - 1];
                        quoteCache.set(liveCacheKey, {
                            timestamp: Date.now(),
                            data: lastCandle
                        });
                        return res.status(200).json({ success: true, data: lastCandle });
                    } else {
                        return res.status(404).json({ success: false, error: 'No quote data' });
                    }
                } catch (error) {
                    console.error(`[LIVE API] Error:`, error);
                    return res.status(500).json({ success: false, error: error.message });
                }

            case 'signal':
                const { generateSignal } = await import('../src/utils/signal.js');
                result = await generateSignal(symbol);
                break;

            case 'review':
                const { generateReview } = await import('../src/utils/review.js');
                const { entry, sl, mode } = req.body;
                if (!entry || !mode) {
                    result = "❌ Data entry dan action (BUY/SELL) wajib diisi.";
                } else {
                    result = await generateReview(mode, symbol, entry, sl);
                }
                break;

            case 'avg':
                const { p1, l1, p2, targetAvg, l2Input, slPercent, tpPercent, feeBuy, feeSell } = req.body;
                if (!p1 || !l1) {
                    result = "❌ Data harga beli lama dan jumlah lot wajib diisi.";
                } else {
                    // Try to fetch current price for simulation if P2 is not manually provided
                    let finalP2 = p2;
                    let currentPrice = null;
                    try {
                        const priceData = await fetchHarga(symbol);
                        // Extract number from and result like "BUVA | 123 | +1%"
                        // fetchHarga returns a string. We need a numerical price for calculations.
                        // However, fetchHarga output is formatted for the bot.
                        // Let's use fetchHistorical or similar for a clean number if possible.
                        const candles = await fetchHistorical(symbol, { limit: 1 });
                        if (candles && candles.length > 0) {
                            currentPrice = candles[0].close;
                            if (!finalP2) finalP2 = currentPrice;
                        }
                    } catch (e) {
                        console.error("Price fetch failed for avg calculator:", e);
                    }

                    if (!finalP2) {
                        return res.json({ success: false, error: 'Harga beli baru (P2) tidak ditemukan dan tidak diisi secara manual.' });
                    } else {
                        const avgData = calculateAvg({
                            symbol,
                            p1: Number(p1),
                            l1: Number(l1),
                            p2: Number(finalP2),
                            targetAvg: targetAvg ? Number(targetAvg) : null,
                            l2Input: l2Input ? Number(l2Input) : null,
                            currentPrice: currentPrice,
                            slPercent,
                            tpPercent,
                            feeBuy,
                            feeSell
                        });
                        try {
                            let reportHtml = await markdownToTelegramHTML(formatAvgReport(avgData));
                            // Ensure newlines from formatAvgReport survive in browser HTML
                            reportHtml = reportHtml.replace(/\n/g, '<br>');

                            return res.json({
                                success: true,
                                data: reportHtml,
                                raw: avgData,
                                active_theme: activeTheme
                            });
                        } catch (genErr) {
                            console.error("Report generation failed:", genErr);
                            return res.json({
                                success: true,
                                data: `<b>Simulasi Selesai</b><br>Kalkulasi berhasil tetapi gagal membangun laporan teks. Cek grafik untuk visualisasi detail.`,
                                raw: avgData,
                                active_theme: activeTheme
                            });
                        }
                    }
                }
                break;

            case 'sector-emitents':
                const { sector } = req.body;
                if (!sector) return res.status(400).json({ error: 'Sector name required' });

                // Check Cache
                const cachedEmitents = sectorEmitentsCache.get(sector);
                if (cachedEmitents && (Date.now() - cachedEmitents.timestamp < SECTOR_EMITENTS_CACHE_TTL)) {
                    console.log(`[CACHE HIT] Sector Emitents for ${sector}`);
                    return res.json({
                        success: true,
                        sector: sector,
                        data: cachedEmitents.data,
                        cached: true
                    });
                }

                console.log(`[CACHE MISS] Fetching Sector Emitents for ${sector}...`);

                // Mapping mapping IDX -> Yahoo Sector
                const sectorMapping = {
                    'Energy': ['Energy'],
                    'Basic Materials': ['Basic Materials'],
                    'Industrials': ['Industrials'],
                    'Consumer Cyclicals': ['Consumer Cyclical'],
                    'Consumer Non-Cyclicals': ['Consumer Defensive'],
                    'Healthcare': ['Healthcare'],
                    'Financials': ['Financial Services'],
                    'Properties': ['Real Estate'],
                    'Technology': ['Technology'],
                    'Infrastructures': ['Communication Services', 'Utilities'],
                    'Logistics': ['Industrials']
                };

                // Curated top tickers for each sector (fallback/boost)
                const curatedTickers = {
                    'Energy': ['ADRO', 'ITMG', 'PTBA', 'PGAS', 'MEDC', 'AKRA'],
                    'Basic Materials': ['TPIA', 'MDKA', 'INCO', 'ANTM', 'BRPT', 'INTP'],
                    'Industrials': ['ASII', 'UNTR', 'AALI', 'SMGR'],
                    'Consumer Cyclicals': ['GOTO', 'BUKA', 'MAPI', 'AMRT', 'MSIN'],
                    'Consumer Non-Cyclicals': ['UNVR', 'ICBP', 'INDF', 'CPIN', 'MYOR'],
                    'Healthcare': ['KLBF', 'MIKA', 'HEAL', 'SILO'],
                    'Financials': ['BBCA', 'BBRI', 'BMRI', 'BBNI', 'BRIS', 'ARTO'],
                    'Properties': ['BSDE', 'PWON', 'CTRA', 'SMRA'],
                    'Technology': ['GOTO', 'BUKA', 'EMT K', 'WIFI'],
                    'Infrastructures': ['TLKM', 'ISAT', 'EXCL', 'JSMR', 'TOWR', 'TBIG'],
                    'Logistics': ['ASSA', 'BIRD', 'SMDR', 'TMAS']
                };

                const targetYSectors = sectorMapping[sector] || [];
                const topTickers = curatedTickers[sector] || [];

                try {
                    // Fetch from DB
                    const { data: dbStocks, error: dbErr } = await supabase
                        .from('stock_fundamentals')
                        .select('symbol, name, full_data')
                        .in('sector', targetYSectors)
                        .limit(20);

                    // Fetch latest quotes for curated tickers to ensure they appear
                    const { fetchQuote } = require('../src/utils/yahoofinance');
                    const results = [];
                    const addedSymbols = new Set();

                    // 1. Add DB Stocks first (they have detailed data)
                    if (dbStocks) {
                        dbStocks.forEach(s => {
                            const sym = s.symbol.replace('.JK', '');
                            results.push({
                                symbol: sym,
                                name: s.name,
                                price: s.full_data?.price || 0,
                                change: s.full_data?.quote?.regularMarketChangePercent || 0
                            });
                            addedSymbols.add(sym);
                        });
                    }

                    // 2. Add Curated if not already added
                    const filteredCurated = topTickers.filter(t => !addedSymbols.has(t));
                    if (filteredCurated.length > 0) {
                        const curatedQuotes = await fetchQuote(filteredCurated.map(t => `${t}.JK`));
                        const quotesArray = Array.isArray(curatedQuotes) ? curatedQuotes : [curatedQuotes];

                        quotesArray.forEach(q => {
                            if (!q) return;
                            const sym = q.symbol.replace('.JK', '');
                            results.push({
                                symbol: sym,
                                name: q.longName || q.shortName || sym,
                                price: q.regularMarketPrice || 0,
                                change: q.regularMarketChangePercent || 0
                            });
                        });
                    }

                    const finalResult = results.sort((a, b) => Math.abs(b.change) - Math.abs(a.change));

                    // Save to Cache
                    sectorEmitentsCache.set(sector, {
                        timestamp: Date.now(),
                        data: finalResult
                    });

                    return res.json({
                        success: true,
                        sector: sector,
                        data: finalResult
                    });
                } catch (err) {
                    console.error('Sector Emitents Error:', err);
                    return res.status(500).json({ error: 'Failed to fetch sector emitents' });
                }

            case 'sectors':
                // Check Cache
                if (sectorsCache && (Date.now() - sectorsCacheTime < SECTOR_CACHE_TTL)) {
                    console.log('[CACHE HIT] Sectors data');
                    return res.json({
                        success: true,
                        data: sectorsCache,
                        cached: true,
                        active_theme: activeTheme
                    });
                }

                console.log('[CACHE MISS] Fetching fresh sectors data...');
                const sectors = await fetchSectors();
                if (!sectors) {
                    return res.status(500).json({ error: 'Gagal mengambil data sektor.' });
                }

                sectorsCache = sectors;
                sectorsCacheTime = Date.now();

                return res.json({
                    success: true,
                    data: sectors,
                    active_theme: activeTheme
                });

            default:
                return res.status(400).json({ error: 'Invalid action' });
        }

        // Convert Markdown to HTML for web display if it's not already HTML
        // fetchHarga returns strings with emojis, some utils return HTML, some Markdown.
        // Ideally we treat everything as HTML or convert MD to HTML.
        // Simple heuristic: if it contains <b> or <br>, assume HTML, else Markdown.
        const isHtml = /<[a-z][\s\S]*>/i.test(result);
        // Even if it is HTML, we might want to run it through marked if it has mixed content? 
        // Actually, existing bot output is mixed.
        // Let's standardise on sending JSON with a 'html' field.

        let htmlOutput = result;
        if (!isHtml) {
            const markedFn = await loadMarked();
            htmlOutput = markedFn(result, { breaks: true });
        }
        // Force newlines to <br> if not handled by marked (e.g. plain text with \n)
        // If marked handled it, it should have inserted <br> for \n
        if (!htmlOutput.includes('<p>') && !htmlOutput.includes('<br>')) {
            htmlOutput = htmlOutput.replace(/\n/g, '<br>');
        }

        res.status(200).json({
            success: true,
            data: htmlOutput,
            active_theme: activeTheme // Added for real-time theme sync
        });

    } catch (error) {
        console.error('[WEB API CRITICAL ERROR]:', error);
        return res.status(500).json({
            error: 'Internal Server Error',
            message: error.message,
            stack: error.stack?.split('\n').slice(0, 3).join(' | ')
        });
    }
};
